package com.versacomllc.training.util;

import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.security.spec.KeySpec;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;
import org.apache.log4j.Logger;
import org.springframework.http.HttpHeaders;
import org.springframework.security.crypto.codec.Hex;

public class CryptographicUtility {
	
	  private static Logger logger = Logger.getLogger(CryptographicUtility.class);
	  
	 /**
	   * Generate a secured random byte array with length 32
	   * 
	   * @return the generated byte array
	   */
	  public static byte[] generateSecureRandom() {
	    final Random r = new SecureRandom();
	    byte[] salt = new byte[32];
	    r.nextBytes(salt);
	    return salt;
	  }

	  /**
	   * 
	   * @param passcode
	   * @param salt
	   *          Base64 representation of salt
	   * @return the hash of the passcode/salt combination or <tt>null</tt> if
	   *         anything has gone wrong.
	   */
	  public static synchronized byte[] encode(char[] passcode, byte[] salt) {
	    int iterations = 1024;
	    int keyLength = 256;
	    KeySpec keySpec = new PBEKeySpec(passcode, salt, iterations, keyLength);
	    SecretKeyFactory factory;
	    byte[] key = null;
	    try {
	      factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
	      key = factory.generateSecret(keySpec).getEncoded();
	    }
	    catch (NoSuchAlgorithmException e) {
	      e.printStackTrace();
	    }
	    catch (InvalidKeySpecException e) {
	      e.printStackTrace();
	    }
	    return key;
	  }


	  public static byte[] decrypt(final byte[] key, final byte[] ciphertext,
	      final byte[] iv) {
	    SecretKey secret = new SecretKeySpec(key, "AES");
	    byte[] plaintext = null;
	    Cipher cipher;
	    try {
	      cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
	      cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
	      plaintext = cipher.doFinal(ciphertext);
	    }
	    catch (NoSuchAlgorithmException e) {
	      e.printStackTrace();
	    }
	    catch (NoSuchPaddingException e) {
	      e.printStackTrace();
	    }
	    catch (InvalidKeyException e) {
	      e.printStackTrace();
	    }
	    catch (InvalidAlgorithmParameterException e) {
	      e.printStackTrace();
	    }
	    catch (IllegalBlockSizeException e) {
	      e.printStackTrace();
	    }
	    catch (BadPaddingException e) {
	      logger.error(e.getMessage()
	          + " ##### BadPaddingException! currentTimeMillis: "
	          + Clock.getInstance().currentTimeMillis());
	    }
	    return plaintext;
	  }

	  /**
	   * 
	   * @param key
	   *          The key to encrypt with
	   * @param data
	   *          They data to be encrypted
	   * @return A {@link Map} object containing two entries:
	   *         <ol>
	   *         <li>the ciphertext</li>
	   *         <li>the initialisation vector for this ciphertext</li>
	   *         </ol>
	   */
	  public static Map<String, byte[]> encrypt(final byte[] key, final byte[] data) {
	    SecretKey secret = new SecretKeySpec(key, "AES");
	    Map<String, byte[]> map = new HashMap<String, byte[]>();

	    try {
	      Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
	      cipher.init(Cipher.ENCRYPT_MODE, secret);
	      AlgorithmParameters params = cipher.getParameters();
	      byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
	      byte[] ciphertext = cipher.doFinal(data);
	      map.put("ciphertext", ciphertext);
	      map.put("iv", iv);
	    }
	    catch (NoSuchAlgorithmException e) {
	      e.printStackTrace();
	    }
	    catch (NoSuchPaddingException e) {
	      e.printStackTrace();
	    }
	    catch (InvalidKeyException e) {
	      e.printStackTrace();
	    }
	    catch (InvalidParameterSpecException e) {
	      e.printStackTrace();
	    }
	    catch (IllegalBlockSizeException e) {
	      e.printStackTrace();
	    }
	    catch (BadPaddingException e) {
	      e.printStackTrace();
	    }
	    return map;
	  }


	  /**
	   * Calculate the digest part A1 for the provided parameters as specified for
	   * Digest Authentication.
	   * 
	   * @param username
	   *          username
	   * @param password
	   *          password
	   * @param realm
	   *          realm
	   * @return digest string
	   */
	  public static String calculateUserDigest(final String username,
	      final String password, final String realm) {

	    String a1 = username + ":" + realm + ":" + password;

	    MessageDigest digest;
	    try {
	      digest = MessageDigest.getInstance("MD5");
	    }
	    catch (NoSuchAlgorithmException e) {
	      throw new IllegalStateException("No MD5 algorithm available!");
	    }

	    return new String(Hex.encode(digest.digest(a1.getBytes())));
	  }

	  /**
	   * Convenience method to convert from UTF8 String to byte array.
	   * 
	   * @param value
	   *          string to convert
	   * @return converted byte array
	   */
	  public static byte[] convertStringToByte(final String value) {
	    if (value == null) {
	      return null;
	    }

	    try {
	      return value.getBytes("UTF8");
	    }
	    catch (UnsupportedEncodingException e) {
	      return null;
	    }
	  }

	  /**
	   * Convenient method to convert from byte array to String.
	   * 
	   * @param value
	   *          byte array to convert
	   * @return converted String
	   */
	  public static String convertByteToString(final byte[] value) {
	    if (value == null) {
	      return null;
	    }

	    try {
	      return new String(value, "UTF8");
	    }
	    catch (UnsupportedEncodingException e) {
	      return null;
	    }
	  }
	  /**
	   * Create basic authentication header.
	   * 
	   * @param username
	   *          username
	   * @param password
	   *          password
	   * @return httpheader
	   */
	  public static HttpHeaders createBasicAuthenticationHeader(
	      final String username, final String password) {
	    return new HttpHeaders() {
	      private static final long serialVersionUID = 1L;

	      {
	        String auth = username + ":" + password;
	        byte[] encodedAuth = Base64.encodeBase64(auth.getBytes(Charset
	            .forName("US-ASCII")));
	        String authHeader = "Basic " + new String(encodedAuth);
	        set("Authorization", authHeader);
	      }
	    };
	  }

	  
}
